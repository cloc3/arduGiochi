/*
	howto di riferimento per la prograamzione dell'accelerometro:
	http://codeyoung.blogspot.it/2009/11/adxl345-accelerometer-breakout-board.html
	specifiche dell'accelerometro:
	http://www.sparkfun.com/datasheets/Sensors/Accelerometer/ADXL345.pdf
*/

#include <letturaIntero.h>
#include <Wire.h>

#define DEVICE (0x53)    //ADXL345 device address
#define TO_READ (6)        //num of bytes we are going to read each time (two bytes for each axis)

byte buff[TO_READ] ;    //6 bytes buffer for saving data read from the device
char str[512];                      //string buffer to transform data before sending it to the serial port

void writeTo(int device, byte address, byte val) {
	Wire.beginTransmission(device); //start transmission to device 
	Wire.write(address);        // send register address
	Wire.write(val);        // send value to write
	Wire.endTransmission(); //end transmission
}

void readFrom(int device, byte address, int num, byte buff[]) {
	Wire.beginTransmission(device); //start transmission to device 
	Wire.write(address);        //sends address to read from
	Wire.endTransmission(); //end transmission

	Wire.beginTransmission(device); //start transmission to device (initiate again)
	Wire.requestFrom(device, num);    // request 6 bytes from device

	int i = 0;
	while(Wire.available())    //device may send less than requested (abnormal)
	{ 
		buff[i] = Wire.read(); // receive a byte
		i++;
	}
  Wire.endTransmission(); //end transmission
}

void setup()
{
	Wire.begin();        // join i2c bus (address optional for master)
	Serial.begin(115200);  // start serial for output

	//Turning on the ADXL345
	writeTo(DEVICE, 0x2D, 0);      
	writeTo(DEVICE, 0x2D, 16);
	writeTo(DEVICE, 0x31, 0); //questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	//writeTo(DEVICE, 0x31, 8); //questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	writeTo(DEVICE, 0x2D, 8);
}

void loop()
{
	int regAddress = 0x32;    //first axis-acceleration-data register on the ADXL345
	int i, x, y, z;
	unsigned long time;

	if (attendiStringaNumerica(numeroCicliRichiesti,corsoLettura)) { // attende una richiesta di acquisizione
		if (! *corsoLettura) {
			for (int count=0;count<*numeroCicliRichiesti;count++) {
				str[0]='\0';
				time=micros(); //tempo di inizio della misura
				//time=millis(); //tempo di inizio della misura
	 			readFrom(DEVICE, regAddress, TO_READ, buff); //read the acceleration data from the ADXL345
				//each axis reading comes in 10 bit resolution, ie 2 bytes.  Least Significat Byte first!!
				//thus we are converting both bytes in to one int

				x = (((int)buff[1]) << 8) | buff[0];
				y = (((int)buff[3])<< 8) | buff[2];
				z = (((int)buff[5]) << 8) | buff[4];

				delay(15); // ritardo consigliato per il ripristino della comunicazione i2c - forse puÃ² essere abbassato implementando la comunicazione seriale SPI.
				sprintf(str, "%lu %d %d %d\n",time, x, y, z);
				Serial.print(str);
				//Serial.write(10);
			}
		*numeroCicliRichiesti=0;
		//Serial.flush();
		}
	}
}
