/*
	howto di riferimento per la prograamzione dell'accelerometro:
	http://codeyoung.blogspot.it/2009/11/adxl345-accelerometer-breakout-board.html
	specifiche dell'accelerometro:
	http://www.sparkfun.com/datasheets/Sensors/Accelerometer/ADXL345.pdf
*/

#include <letturaIntero.h>
#include <Wire.h>

#define DEVICE0 (0x53)		// indirizzo fisico per l'accelerometro in modalità i2c, con SDO=0
#define DEVICE1 (0x1D)		// indirizzo fisico per l'accelerometro in modalità i2c, con SDO=1

#define TO_READ (6)			// lunghezza in byte dello spazio dati (due byte per ciascun asse)

byte buff[TO_READ] ;		// preparazione dello spazio di memoria dedicato all'acquisizione dei dati
char str[512];					// stringa destinata alla rappresentazione dei dati in formato carattere

void writeTo(int device, byte address, byte val) {
	Wire.beginTransmission(device);	// avvio della comunicazione i2c, tra l'accelerometro e arduino
	Wire.write(address);						// impostazione dell'indirizzo fisico del registro su cui si desidera effettuare la scrittura.
	Wire.write(val);								// invio del valore da scrivere
	Wire.endTransmission();					// chiusura della comunicazione
}

void readFrom(int device, byte address, int num, byte buff[]) {
	Wire.beginTransmission(device);	// avvio della comunicazione i2c, tra l'accelerometro e arduino
	Wire.write(address);						// impostazione dell'indirizzo fisico del registro su cui si desidera effettuare la lettura
	Wire.endTransmission();					// chiusura della comunicazione

	Wire.beginTransmission(device);	// riapertura della comunicazione (l'accelerometro ha ricevuto l'indirizzo del registro da leggere,
																	// ma non è ancora stata effettuata alcuna lettura
	Wire.requestFrom(device, num);	// richiesta di leggere 6 bytes, a partire dall'indirizzo comunicato in precedenza

	int i = 0;
	while(Wire.available())					// attesa della lettura
	{ 
		buff[i] = Wire.read();				// ricezione dei byte richiesti, uno alla volta
		i++;
	}
  Wire.endTransmission();					// chiusura della comunicazione
}

void setup()
{
	Wire.begin();										// impostazione del bus i2c
	Serial.begin(115200);						// impostazione della porta seriale

	//operazioni di accensione dell'accelerometro ADXL345
	writeTo(DEVICE0, 0x2D, 0);      
	writeTo(DEVICE0, 0x2D, 16);
	writeTo(DEVICE0, 0x31, 0);				// questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	//writeTo(DEVICE0, 0x31, 8);			// questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	writeTo(DEVICE0, 0x2D, 8);
	//writeTo(DEVICE0, 0x2C, 0xB);			//DATA RATE a 200Hz
	writeTo(DEVICE1, 0x2D, 0);      
	writeTo(DEVICE1, 0x2D, 16);
	writeTo(DEVICE1, 0x31, 0);				// questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	//writeTo(DEVICE1, 0x31, 8);			// questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	writeTo(DEVICE1, 0x2D, 8);
	//writeTo(DEVICE1, 0x2C, 0xB);			//DATA RATE a 200Hz
}

char *misura()
{
	int regAddress = 0x32;					// indirizzo fisico del primo registro dati sull'accelerometro ADXL345
	int x0, y0, z0, x1, y1, z1;
	unsigned long time;

	time=micros();																// tempo dall'accensione di arduino, in microsecondi
	readFrom(DEVICE0, regAddress, TO_READ, buff);	// lettura del campo dati sull'accelerometro ADXL345
						// per ciascun asse sono riservati 10 bit di precisione (più il segno?). Il primo byte contiene le cifre più significative
						// each axis reading comes in 10 bit resolution, ie 2 bytes. Least Significant Byte first!!
						// è necessario convertire i dati in variabili intere

	x0 = (((int)buff[1]) << 8) | buff[0];
	y0 = (((int)buff[3]) << 8) | buff[2];
	z0 = (((int)buff[5]) << 8) | buff[4];

	readFrom(DEVICE1, regAddress, TO_READ, buff);	// lettura del campo dati sull'accelerometro ADXL345
	x1 = (((int)buff[1]) << 8) | buff[0];
	y1 = (((int)buff[3]) << 8) | buff[2];
	z1 = (((int)buff[5]) << 8) | buff[4];

	delay(5); // il ritardo consigliato da blogspot per il ripristino della comunicazione i2c è 15 millisecondi
						// il data rate può modificato usando il registro 0x2C 

	sprintf(str,"%lu %d %d %d %d %d %d\n", time, x0, y0, z0, x1, y1, z1);
	return str;
}

void loop()
{
	unsigned long time;

	if (attendiStringaNumerica(numeroCicliRichiesti,corsoLettura)) { // attende una richiesta di acquisizione
		if (! *corsoLettura) {
			for (int count=0;count<*numeroCicliRichiesti;count++) {
				Serial.print(misura());
			}
		*numeroCicliRichiesti=0;
		}
	}
}
