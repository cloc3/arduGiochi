/*
	Questo skecth implementa la funzione ritardoSegnale e ne stampa l'output sulla porta seriale.
*/

/*
	howto di riferimento per la programzione dell'accelerometro:
	http://codeyoung.blogspot.it/2009/11/adxl345-accelerometer-breakout-board.html
	specifiche dell'accelerometro:
	http://www.sparkfun.com/datasheets/Sensors/Accelerometer/ADXL345.pdf
*/

#include <Wire.h>
#include <letturaIntero.h>
#include <ritardoSegnale.h>

void misura()
{
	int regAddress = 0x32;					// indirizzo fisico del primo registro dati sull'accelerometro ADXL345

	lettura->marcaTempo=micros();																// tempo corrente dall'accensione di arduino, in microsecondi
	readFrom(DEVICE0, regAddress, TO_READ, buff);	// lettura del campo dati sull'accelerometro ADXL345
						// per ciascun asse sono riservati 10 bit di precisione (più il segno?). Il primo byte contiene le cifre più significative
						// each axis reading comes in 10 bit resolution, ie 2 bytes. Least Significant Byte first!!
						// è necessario convertire i dati in variabili intere

	lettura->acc0.x = (((int)buff[1]) << 8) | buff[0];
	lettura->acc0.y = (((int)buff[3]) << 8) | buff[2];
	lettura->acc0.z = (((int)buff[5]) << 8) | buff[4];

	readFrom(DEVICE1, regAddress, TO_READ, buff);	// lettura del campo dati sull'accelerometro ADXL345
	lettura->acc1.x = (((int)buff[1]) << 8) | buff[0];
	lettura->acc1.y = (((int)buff[3]) << 8) | buff[2];
	lettura->acc1.z = (((int)buff[5]) << 8) | buff[4];
}

unsigned long ritardoSegnale()
{
	int i, z0Medio, z1Medio;

	boolean attesa0, attesa1; // stato di attesa di un evento 
	unsigned long inizioAttesa;

	attesa0=1;
	attesa1=1;

	/*	Questo blocco valuta un valore medio per la componente z di accelerazione
			Utile in fase di tartura
	*/
	z0Medio=0;
	z1Medio=0;
	for (i=0; i<10;i++) { 
		misura();
		z0Medio +=lettura->acc0.z;
		z1Medio +=lettura->acc1.z;
	}
	z0Medio /=10;
	z1Medio /=10;

	/* Questo ciclo attende le variazioni dalla media e valuta i ritardi */ 
	while (attesa0 | attesa1) {
		misura();
		if ( abs(lettura->acc0.z - z0Medio) > SOGLIA) {
			attesa0=0;
			if (attesa1) inizioAttesa = lettura->marcaTempo;
		}
		if ( abs(lettura->acc1.z - z1Medio) > SOGLIA) {
			attesa1=0;
			if (attesa0) inizioAttesa = lettura->marcaTempo;
		}
	}

	return abs(lettura->marcaTempo - inizioAttesa);
}

void setup()
{
	Wire.begin();										// impostazione del bus i2c
	Serial.begin(115200);						// impostazione della porta seriale

	//operazioni di accensione dell'accelerometro ADXL345
	writeTo(DEVICE0, 0x2D, 0);     	// Dispone l'accelerometro in standby. 
	writeTo(DEVICE0, 0x2C, 0xC);		// clock SCL a 400Hz -> Data rate 800 Hz
	writeTo(DEVICE0, 0x31, 0);			// questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	//writeTo(DEVICE0, 0x31, 8);		// questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	//writeTo(DEVICE0, 0x2D, 16);			// pone il dispositivo in auto sleep
	writeTo(DEVICE0, 0x2D, 8);			// attiva la modalità di lettura

	//operazioni di accensione dell'accelerometro ADXL345
	writeTo(DEVICE1, 0x2D, 0);     	// Dispone l'accelerometro in standby. 
	writeTo(DEVICE1, 0x2C, 0xC);		// clock SCL a 400Hz -> Data rate 800 Hz
	writeTo(DEVICE1, 0x31, 0);			// questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	//writeTo(DEVICE1, 0x31, 8);		// questa configurazione seleziona il range +/-2g. impostare 8 per ottenere la massima risoluzione 4mg/LSB (da capire meglio)
	//writeTo(DEVICE1, 0x2D, 16);			// pone il dispositivo in auto sleep
	writeTo(DEVICE1, 0x2D, 8);			// attiva la modalità di lettura
}

void loop()
{
	if (attendiStringaNumerica(numeroCicliRichiesti,corsoLettura)) { // attende una richiesta di acquisizione
		if (! *corsoLettura) {
			for (int count=0;count<*numeroCicliRichiesti;count++) {
				misura();
				//delay(5);	//alcuni browser (per esempio webkit) richiedono di introdurre un ritardo per ridurre il data rate.
				sprintf(str,"%lu %d %d %d %d %d %d\n", lettura->marcaTempo, lettura->acc0.x, lettura->acc0.y, lettura->acc0.z, lettura->acc1.x, lettura->acc1.y, lettura->acc1.z);
				Serial.print(str);
				/*
				Serial.print("ritardo misurato = ");
				Serial.println(ritardoSegnale());
				*/
			}
		*numeroCicliRichiesti=0;
		}
	}
}
